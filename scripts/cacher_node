#!/usr/bin/env python3
import rospy
import json

from robonomics_liability.msg import Liability
from robonomics_msgs.msg import Result
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, scoped_session

from helpers.models import Liability as L, Multihash as M
from helpers.models import Base, engine, db_session
from helpers.ipfs import ipfs_download


class CacherNode:

    def __init__(self):
        rospy.init_node("cacher")
        rospy.loginfo("Launching cacher node...")

        # ROS Topics
        rospy.Subscriber("/liability/incoming", Liability, self.incoming_liability)
        rospy.Subscriber("/liability/infochan/incoming/result", Result, self.incoming_result)

        # Database
        Base.metadata.create_all(engine)
        self.session = db_session()

        rospy.loginfo("Cacher node is launched!")

    def incoming_liability(self, liability: Liability):
        rospy.loginfo(liability)

        model = self.resolve_model(liability.model.multihash)
        objective = self.resolve_rosbag(model, liability.objective.multihash)

        l = L(
                address     = liability.address.address,
                promisee    = liability.promisee.address,
                promisor    = liability.promisor.address,
                lighthouse  = liability.lighthouse.address,
                token       = liability.token.address,
                cost        = liability.cost.uint256,
                validator   = liability.validator.address,
                validatorFee = liability.validatorFee.uint256
                )

        l.model.append(model)
        l.objective.append(objective)

        self.session.add(l)
        self.session.commit()
        rospy.loginfo(l)

    def resolve_model(self, model: str) -> M:
        try:
            data = ipfs_download(model)
        except TimeoutError as e:
            data = ""

        return M(hash = model, data = data)

    def resolve_rosbag(self, model: M, ipfs_hash: str) -> M:
        try:
            model_scheme = json.loads(model.data)
            rosbag_scheme = model_scheme["rosbag_scheme"]
            bag = IpfsRosBag(multihash=Multihash(ipfs_hash))
            data = self.apply_scheme(rosbag_scheme, bag.messages)
        except ValueError as e:
            rospy.loginfo("Model is not valid JSON")
            data = ""

        return M(hash = ipfs_hash, data = data)

    def apply_scheme(self, rosbag: dict, messages: dict) -> dict:
        pass

    def incoming_result(self, result: Result):
        rospy.loginfo(result)
        q = self.session.query(L).filter(L.address == result.liability.address).update({L.result: result.result.multihash})
        self.session.commit()
        rospy.loginfo(q)

    def spin(self):
        rospy.spin()


if __name__ == "__main__":
    CacherNode().spin()

